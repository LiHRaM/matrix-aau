\chapter{Implementation}

\section{Embedded Database Support}
As Dendrite is an active open source project, we were able to submit a pull request to the repository to synchronize the pure Go P2P Dendrite with the mainline development.
In concrete terms, this pull request merges the \github{matrix-org/dendrite/p2p} branch with \texttt{master}.
The pull request is documented at \github{matrix-org/dendrite/956}.

The pull request also introduces a new binary, \texttt{dendrite-demo-libp2p}, which can be run as a standalone peer-to-peer server.
The binary takes two optional input parameters: \textit{name} and \textit{port}, which are used to avoid collision on the same host.
For example, in order to spawn two separate servers on the same computer for testing purposes, one could write:

\begin{lstfloat}
	\begin{lstlisting}[
        caption={
            Running multiple instances of \texttt{dendrite-demo-libp2p} for testing purposes.
            The flags passed are used to avoid collision.
            The binary creates several SQLite databases using the name parameter.
        }
    ]
# This command is run in one terminal
$ ./dendrite-demo-libp2p -port 8080 -name nr1

# This command is run in another terminal
$ ./dendrite-demo-libp2p -port 8081 -name nr2
\end{lstlisting}
\end{lstfloat}

\section{Compiling Dendrite for Android}
Dendrite is written in the Go programming language, which supports a variety of operating systems, including Android and~iOS\@.
The Gomobile program described in Section~\ref{sec:gomobile} compiles binaries and libraries for Android, and also generates Android code via Java which enables native Android applications to reference the interface directly.
We refactor the \texttt{dendrite-demo-libp2p} binary into a library stored at \github{LiHRaM/server} which can be compiled by Gradle\footnote{https://gradle.org}, the build system used by RiotX and Riot.
The library exports a single function, \texttt{Init}, with the signature seen in Listing~\ref{lst:dendrite_init}.
Init starts an instance of a Dendrite server, which means that it runs indefinitely.
In order to pass information from Dendrite to the calling Java library, we add a \texttt{Callback} interface, which can be implemented on the Java side.
Listing~\ref{lst:vector_callback} shows the callback we implement on the Java side.

\begin{lstfloat}
	\begin{lstlisting}[
  language=Go,
  label={lst:dendrite_init},
  caption={
    The Init function spawns a Dendrite server as a monolith.
    The monolith creates SQLite databases in the directory specified by \texttt{path}.
    The other two parameters are used to avoid namespace and port clashing.
    This is necessary for spawning more than one instance on the same host.
}]
// Callback provides the the caller a way to respond to the port being set.
type Callback interface {
	SetPort(int)
}

// Init starts the Dendrite server in p2p mode
func Init(
    path string, 
    instanceName string, 
    instancePort int, 
    callback Callback) {/* not included */}
\end{lstlisting}
\end{lstfloat}


\begin{lstfloat}
	\begin{lstlisting}[
    language=Java,
    label={lst:vector_callback},
    caption={
        The \texttt{Init} function expects an object which implements the \texttt{Callback} interface.
    }
]
private static class PortActivatedCallback implements Callback {
    private long mDendritePort = 0;

    long getPort() {
        this.blockOnPort();
        return mDendritePort;
    }

    private void blockOnPort() {
        while (mDendritePort == 0) {

        }

        Log.d(LOG_TAG, "Port accessed :" + mDendritePort);
    }

    @Override
    public void setPort(long l) {
        mDendritePort = l;
    }
}
\end{lstlisting}
\end{lstfloat}

Gomobile can be used to bind the underlying library, which has the interface as shown in Listing~\ref{lst:dendrite_init}.
This command generates an \textbf{A}ndroid \textbf{Ar}chive \texttt{(.aar)} file\footnote{Android Archives and their use are described at \url{https://developer.android.com/studio/projects/android-library}}, which includes the compiled Go code and Java bindings.

\section{Running Dendrite on Android}
We modify Riot such that it can run its own Dendrite server.
First, we modify the entrypoint for the Android application, \texttt{VectorApp}.
The entrypoint is called every time the application launches, which allows us to ensure that an instance of Dendrite is running.
Specifically, we introduce our changes into the \texttt{onCreate} method.
In Listing~\ref{lst:vectorapp}, we list the changes made to this entrypoint.

The Android developer documentation suggests the use of dynamic ports for running services, since the package authors cannot assume that a given port is free.
The documentation suggests the use of an API in order to get the next available port.
Unfortunately, this API returns a raw \texttt{WebSocket} instead of the number of the port, which we cannot pass to the Dendrite library, since Gomobile only supports simple types.
Therefore, we intentionally pass \texttt{0} as a parameter for the port assigned to Dendrite.
The Dendrite library looks for the next available port and passes it to the \texttt{Callback} object, which the Java side stores and uses to connect to the homeserver.

\begin{lstfloat}
	\begin{lstlisting}[
        language=Java,
        label={lst:vectorapp},
        caption={
            VectorApp is the main entry point of the Android application.
            \texttt{onCreate} is called every time the app is started.
        }
    ]
// The modified VectorApp in VectorApp.java
public class VectorApp extends MultiDexApplication {
    /* PortActivatedCallBack definition */

    private Uri mDendriteUrl;

    public Uri getDendriteUrl() {
        return mDendriteUrl;
    }

    @Override
    public void onCreate() {
        /* not included */
        PortActivatedCallback cb = new PortActivatedCallback();
        Runnable dendriteTask = () -> Server.init(
                getFilesDir().getPath(),
                "dendrite-server",
                0,
                cb
        );
        new Thread(dendriteTask).start();
        mDendriteUrl = Uri.parse("http://localhost:" + cb.getPort());
        /* not included */
    }
}
\end{lstlisting}
\end{lstfloat}

We update the registration process so that the default homeserver is the one created by the Riot application during the \texttt{onCreate} event.
This is done in \texttt{LoginActivity.java}, which handles both registration and login.
There, as seen in Listing~\ref{lst:login_activity}, we rewrite the \texttt{getHomeServerUrl} to return the value stored by \texttt{VectorApp}.

\begin{lstfloat}
	\begin{lstlisting}[
    language=Java,
    label={lst:login_activity},
    caption={
        A method which we modify in \texttt{LoginActivity.java} to return the custom homeserver url generated in \texttt{VectorApp}.
    }
]
private String getHomeServerUrl() {
    return VectorApp.getInstance().getDendriteUrl().toString();
}
\end{lstlisting}
\end{lstfloat}

Typically, when a user registers with a Matrix server, the \ac{URL} does not change.
The client therefore stores the homeserver \ac{URL} along with the user information.
We add logic which updates the homeserver \ac{URL} whenever the user information is fetched, as seen in Listing~\ref{lst:matrix_java}.
This prevents the client from trying to connect to the wrong port.

\begin{lstfloat}
	\begin{lstlisting}[
    language=Java,
    label={lst:matrix_java},
    caption={
        \texttt{Matrix.java} contains a Singleton class which controls access to the Matrix SDK along with session management.
        We modify \texttt{getDefaultSession} so that it updates the homeserver \ac{URL} to match the most recent one available.
    }
]
public synchronized MXSession getDefaultSession() {
    /* not included */
    for (HomeServerConnectionConfig config : hsConfigList) {

        // Update the port of the homeserver
        config.setHomeserverUri(
            VectorApp.getInstance().getDendriteUrl());

        /* not included */
    }
}
\end{lstlisting}
\end{lstfloat}

% \begin{lstfloat}
%     \begin{lstlisting}[
%     language=Java,
%     label={lst:label},
%     caption={
%         Lorem ipsum.
%     }
% ]
% // Code...
% \end{lstlisting}
% \end{lstfloat}