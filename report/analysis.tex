\chapter{Analysis}
Any solution to the initial problem requires an understanding of the protocols involved.
We begin the analysis by examining the Matrix Open Standard.

\section*{Aside: \faGithub~Github}
Due to the open nature of the projects that this report considers, referring to repositories, issues and pull requests can become quite repetitive.
In order to make it easier to write and read these references, we refer to GitHub issues and pull requests in the following manner: \github{org/repository\#ID}, where ID is a number identifying the issue.
We refer to repositories simply as \github{org/repository}.
For example, for the pull request at \url{https://github.com/lihram/aau/pull/1}, we write: \github{lihram/aau\#1}.
Referring to multiple issues or pull requests is done similarly, \github{lihram/aau\#1,2}.

\section{The Matrix Standard}
The Matrix standard defines how entities interact in the Matrix network.
An \ac{API} is a way in which programs can define how they communicate.
The Matrix Standard defines several \ac{API}s.
Each of these \ac{API}s is expected to communicate using \ac{JSON} over \ac{REST}.
Th there are many issues and pull requests residing on Github that we might refer to
\begin{itemize}
    \item \textbf{Client-Server}: A \textit{homeserver} interacting with a \textit{client}. In peer-to-peer Matrix, the \textit{client} and \textit{homeserver} are both on-device.
    \item \textbf{Server-Server}: Two or more \textit{homeservers} interacting. The servers synchronize state via \textit{federation}.
    \item \textbf{Application Service}: Interoperability and extensibility is largely achieved through application services, which can \textit{bridge} external chat protocols to Matrix, allowing e.g. interoperability between \ac{IRC} and Matrix.
    \item \textbf{Identity Service}: Identity services enable external identities, such as email, mobile numbers, or other services to be attached to a Matrix user.
    \item \textbf{Push Gateway}: The way push notifications are implemented for Matrix events.
\end{itemize}

Each homeserver needs to be registered with a \ac{DNS} entry, by which they are identified.

\subsection{Central Concepts}
The standard can be decomposed into a set of entities which interact.
It is vital to understand how these entities interact, and how these interactions may affect a peer-to-peer implementation.

\paragraph{User}
A user is registered with a homeserver, and identified thereby, e.g. \texttt{@user:example.com}.
The user participates in conversations via rooms.
The user's chat history is managed by all homeservers with users which participate in these rooms.

\paragraph{Device}
A client application corresponds roughly to what is termed a device in the Matrix standard.
There are some caveats, for example, the same client on different browsers will be considered different devices per browser.
A smartphone with separate mobile applications will also be considered multiple devices per application.
The access of devices can be revoked via the Matrix \ac{API}, and they are used for managing encryption keys.
Clients register themselves as devices on the first login.

\paragraph{Event}
All state changes are represented by events.
Each event has a \texttt{type} field, which follows the Java package naming convention to avoid conflicts.
For example, a message event has the type \texttt{m.room.message}.
The Matrix Standard reserves all types starting with "\texttt{m.}".
Events typically happen in the context of a room.

\paragraph{Event Graph}
Because of network partitions, we cannot guarantee that all homeservers are connected to each other at all times.
The specification specifies how events are structured, so that each homeserver may eventually become consistent with the others.
The events are stored in a partially ordered \ac{DAG}.
Events are assigned a monotonically increasing \texttt{depth} to ease comparison.

\paragraph{Room}
Rooms serve as the unit to which users can publish events.
They are a flexible concept, but also a simple one.
In order to send a direct message to another user, the user will have to create a room, invite the other user and publish a message to the room.
Rooms allow an arbitrary amount of participants, and can be managed by users with the sufficient authority.
Authority in rooms is represented by a power level, which is between 0 and 100.
The default power level is 0.
When users publish events to a room, only those with a sufficient power level receive the event.
Rooms have a single identifier, which is written like so: \texttt{!id:example.com}, and can have several aliases, which are written: \texttt{\#alias:domain}.
Although a room is identified by a domain, it is federated and therefore not hosted only on its original homeserver.
Rooms all have a specific version, which specifies how they operate.
When new features are implemented for rooms, they are made available by adding a new version.
Rooms change versions via upgrades.

\paragraph{Identity}
The standard supports mappings of third party identities to Matrix identities.
Examples of third party entities are email, social media accounts and phone numbers.

\paragraph{Profiles}
Users can store information in their profiles, such as images, display names, etc.

\subsection{Client-Server}
The \textit{homeserver} is essentially a database with an \ac{API} which can be accessed by the client via \ac{HTTP} \ac{API} calls.
The client \ac{API} provides commands for sending messages, controlling rooms and synchronizing conversation history.
Clients may use both \ac{HTTP} and \ac{HTTPS}.

\subsection{Server-Server}
Due to the decentralized nature of the Matrix network, the server-server \ac{API} provides commands for synchronizing message history by pushing and retrieving messages, and sharing user information.
Servers communicate in three main ways:
\begin{itemize}
    \item{
        \textbf{\ac{PDU}:} 
        A broadcast event which is historically important and shall be stored.
    }
    \item{
        \textbf{\ac{EDU}:}
        A 1-to-1 event which is not historically important, does not need to be stored, and does not require a response.
    }
    \item{
        \textbf{Queries:}
        Requests for information and the corresponding response.
    }
\end{itemize}
Servers must use \ac{HTTPS}.

\subsection{Application Service}
Homeservers are extended via Application Service \ac{API}s, which are privileged plugins.
These plugins are meant to work on any \textit{homeserver} which correctly implements the Matrix standard.
Application Services observe events from homeservers, and can broadcast events into rooms in which they participate.
Homeservers are responsible for passing events to Application Services, which they can be configured to do via configuration files.

\subsection{Identity Service}
This \ac{API} establishes a method for mapping third-party identifiers to Matrix identifiers.
This allows people to find Matrix users by alternative service identifiers, such as email or their telephone numbers, or accounts at different services.

\subsection{Push Gateway}
The homeserver can forward events to the Push Gateway, which then passes this information to push notification services.
While a dedicated homeserver can be expected to run at all times, a peer-to-peer homeserver running on a mobile device should only run when strictly necessary.
Push notifications could therefore be useful, but would have to be external to the homeserver running on-device.


\section{Matrix Spec Changes}
The Matrix standard is developed in the open.
There is a defined process for proposing changes, which are known as Matrix Spec Changes\cite{matrix_org_spec_changes}.
This process allows third parties to contribute to the Matrix standard and provide assistance with open proposals.
With regard to peer-to-peer Matrix on mobile devices, the current spec has limitations:
\begin{itemize}
    \item{
        \textbf{Centralized Accounts}: 
        Although Matrix is a decentralized protocol, accounts are currently centralized.
        As a peer-to-peer implementation would be running a homeserver per device, a user would have to register multiple accounts.
        There is already an issue for decentralized user accounts on Matrix in \github{matrix-org/matrix-doc\#915}.
    }
    \item{
        \textbf{Homeserver identities}:
        A homeserver is identified by a DNS record, which makes it impossible to roam between networks and IP addresses on mobile devices.
        This issue has been raised several times, for example in \github{matrix-org/matrix-doc\#710,712}.
    }
\end{itemize}
These limitations must be solved in order to properly solve the initial problem stated in section \ref{subsec:initial_problem_statement}.

\section{Official Homeservers}
The Matrix organization has two official homeservers, Synapse\cite{matrix_org_synapse} and Dendrite\cite{matrix_org_dendrite}.
Homeservers perform the bulk of the work in the Matrix network.

\subsection{Synapse}
Synapse is the reference implementation of the homeserver \ac{API}s.
It is hosted at \github{matrix-org/synapse}.
TODO:
    Describe the architecture of Synapse.

\paragraph{Synapse Code}
Synapse is written in Python 3, and can use either SQLite or PostgreSQL for metadata storage.
Python is a dynamically typed language, designed to be run by an interpreter.
This has negative performance implications:
\begin{itemize}
    \item{
        \textbf{Program Memory}: 
        The entire program and is stored in the heap.
        Allocating memory on the heap is more expensive than the stack, and requires garbage collection.
    }
    \item{
        \textbf{Latency vs. Throughput}:
        \ac{AOT} compilers perform heavy optimizations on code in the compilation step.
        These optimizations are more difficult to make during interpretation, as the interpreter has to compromise between latency and throughput.
        In other words, the more optimization the interpreter performs, the longer it takes the program to start.
    }
    \item{
        \textbf{The Power of Types}:
        Strongly typed languages provide more metadata than their weakly typed counterparts, which compilers can use for powerful optimizations.
        Refactoring strongly typed programs is also safer, as the interfaces for the functions are more clearly defined, allowing tooling to assist the programmer to a greater degree.
    }
\end{itemize}

Synapse is considered stable and feature-complete with regard to the specification, which Dendrite is not.

\subsection{Dendrite}
Because of the performance and scalability issues that Synapse faces, it is not the base for future experimentation such as peer-to-peer infrastructure.
Instead, the bulk of that work goes on in the Dendrite implementation.
It is hosted at \github{matrix-org/dendrite}.

\begin{figure}
    \centering
    \resizebox{0.9\linewidth}{!}{\input{graphics/dendrite_design.tex}}
    \caption{
        The homeserver can be separated into two main components: \textit{writers} and \textit{readers}.
        Writers respond to API requests by appending to the event log.
        Readers respond to API requests by returning information from the event log.
        Source: \cite{dendrite_design_md}.
    }
    \label{fig:dendrite_design}
\end{figure}

\paragraph{Dendrite Architecture}
The Dendrite design aims to increase simplicity and improve scalability issues in Synapse by using a log based architecture for events.
The central concept is therefore the \textit{event log} which is a history of everything that has happened in a room.
The event log is append only, and accessed by two types of components: \textit{writers} and \textit{readers}.
An example of a writer could be the API that marks a user as active.
A reader could be the logic that synchronizes state with the client.
Figure \ref{fig:dendrite_design} provides a high-level illustration of the flow of data in this design.
Writers and readers must also have some way of computing the room state from the event log, or querying the room state from a central mediator component, such as a room server.
This allows writers to verify that an event is valid before appending it to the log.
Readers in a similar manner use the room state to know which servers and users have enough permissions to view the events.

\paragraph{Dendrite Code}
Dendrite is written in Go\cite{golang_org} and separated into several packages.
The Go programming language supports Android compilation, and Dendrite should therefore be portable to the smartphone.
The peer-to-peer code is implemented on the \texttt{master} branch for WASM, and depends on SQLite, which allows the homeserver to run completely in the browser.
Unfortunately, the WASM implementation of peer-to-peer Dendrite does not support cross-compilation for Android, and must instead be in pure Go.
The \texttt{p2p} branch has a pure Go implementation of peer-to-peer, but is still using postgres.
In order to use the latest developments for peer-to-peer Matrix, the \texttt{p2p} branch must be merged with \texttt{master}.

\section{Mobile Clients}
\subsection{Riot}
\subsection{RiotX}

% \section{Problem Statement}
% \subsection{Requirements for Mobile}
% The Application Service, Identity Service and Push Gateway \ac{API}s are not strictly necessary for a minimal version of peer-to-peer Matrix.
% The core functionality is provided by the client-server and server-server \ac{API}s.
% There are pre-existing implementations of both homeservers and clients which could be combined in order to provide such a service.

% \begin{itemize}
%     \item 
% \end{itemize}
