    \chapter{Analysis}
We begin the analysis by examining the Matrix Open Standard.

\section{The Matrix Standard}
An \ac{API} is a way in which programs can define how they communicate.
The Matrix Standard defines several \ac{API}s.
Each of these \ac{API}s is expected to communicate using \ac{JSON} over \ac{REST}.
The following \ac{API}s are defined\cite{matrix_org_spec}:
\begin{itemize}
    \item \textbf{Client-Server}: A \textit{homeserver} interacting with a \textit{client}. In peer-to-peer Matrix, the \textit{client} and \textit{homeserver} are both on-device.
    \item \textbf{Server-Server}: Two or more \textit{homeservers} interacting. The servers synchronize state via \textit{federation}.
    \item \textbf{Application Service}: Interoperability and extensibility is largely achieved through application services, which can \textit{bridge} external chat protocols to Matrix, allowing e.g. interoperability between \ac{IRC} and Matrix.
    \item \textbf{Identity Service}: Identity services enable external identities, such as email, mobile numbers, or other services to be attached to a Matrix user.
    \item \textbf{Push Gateway}: The way push notifications are implemented for Matrix events.
\end{itemize}

Each homeserver needs to be registered with a \ac{DNS} entry, by which they are identified.


\subsection{Standard Terminology}
We explain the different entities as defined by the Matrix standard.

\paragraph{User}
A user is registered with a homeserver, and identified thereby, e.g. \texttt{@user:example.com}.
The user participates in conversations via rooms.
The user's chat history is managed by all homeservers with users which participate in these rooms.

\paragraph{Device}
A client application corresponds roughly to what is termed a device in the Matrix standard.
There are some caveats, for example, the same client on different browsers will be considered different devices per browser.
A smartphone with separate mobile applications will also be considered multiple devices per application.
The access of devices can be revoked via the Matrix \ac{API}, and they are used for managing encryption keys.
Clients register themselves as devices on the first login.

\paragraph{Event}
All state changes are represented by events.
Each event has a \texttt{type} field, which follows the Java package naming convention to avoid conflicts.
For example, a message event has the type \texttt{m.room.message}.
The Matrix Standard reserves all types starting with "\texttt{m.}".
Events typically happen in the context of a room.

\paragraph{Event Graph}
Because of network partitions, we cannot guarantee that all homeservers are connected to each other at all times.
The specification specifies how events are structured, so that each homeserver may eventually become consistent with the others.
The events are stored in a partially ordered \ac{DAG}.
Events are assigned a monotonically increasing \texttt{depth} to ease comparison.

\paragraph{Room}
Rooms serve as the unit to which users can publish events.
They are a flexible concept, but also a simple one.
In order to send a direct message to another user, the user will have to create a room, invite the other user and publish a message to the room.
Rooms allow an arbitrary amount of participants, and can be managed by users with the sufficient authority.
Authority in rooms is represented by a power level, which is between 0 and 100.
The default power level is 0.
When users publish events to a room, only those with a sufficient power level receive the event.
Rooms have a single identifier, which is written like so: \texttt{!id:example.com}, and can have several aliases, which are written: \texttt{\#alias:domain}.
Although a room is identified by a domain, it is federated and therefore not hosted only on its original homeserver.
Rooms all have a specific version, which specifies how they operate.
When new features are implemented for rooms, they are made available by adding a new version.
Rooms change versions via upgrades.

\paragraph{Identity}
The standard supports mappings of third party identities to Matrix identities.
Examples of third party entities are email, social media accounts and phone numbers.

\paragraph{Profiles}
Users can store information in their profiles, such as images, display names, etc.

\subsection{Client-Server}
The \textit{homeserver} is essentially a database with an \ac{API} which can be accessed by the client via \ac{HTTP} \ac{API} calls.
The client \ac{API} provides commands for sending messages, controlling rooms and synchronizing conversation history.
Clients may use both \ac{HTTP} and \ac{HTTPS}.

\subsection{Server-Server}
Due to the decentralized nature of the Matrix network, the server-server \ac{API} provides commands for synchronizing message history by pushing and retrieving messages, and sharing user information.
Servers communicate in three main ways:
\begin{itemize}
    \item \ac{PDU}: A broadcast event which is historically important and shall be stored.
    \item \ac{EDU}: A 1-to-1 event which is not historically important, does not need to be stored, and does not require a response.
    \item Queries: Requests for information and the corresponding response.
\end{itemize}
Servers must use \ac{HTTPS}.

\subsection{Application Service}
Homeservers are extended via Application Service \ac{API}s, which are privileged plugins.
These plugins are meant to work on any \textit{homeserver} which correctly implements the Matrix standard.
Application Services observe events from homeservers, and can broadcast events into rooms in which they participate.
Homeservers are responsible for passing events to Application Services, which they can be configured to do via configuration files.

\subsection{Identity Service}
This \ac{API} establishes a method for mapping third-party identifiers to Matrix identifiers.
This allows people to find Matrix users by alternative service identifiers, such as email or their telephone numbers, or accounts at different services.

\subsection{Push Gateway}
The homeserver can forward events to the Push Gateway, which then passes this information to push notification services.
While a dedicated homeserver can be expected to run at all times, a peer-to-peer homeserver running on a mobile device should only run when strictly necessary.
Push notifications could therefore be useful, but would have to be external to the homeserver running on-device.


\subsection{Matrix Spec Changes}


Contributions in this report can be submitted against the Matrix standard, which is developed in the open, and has an established process for change\cite{matrix_org_spec_changes}.
Developing peer-to-peer Matrix for mobile requires several changes to the spec, such as decentralized accounts

\subsection{Planned Changes}
TODO:
    Discuss the changes to this spec that might influence how we understand or might want to approach the task.

\subsection{Peer-to-Peer Implications}
TODO: 
    Discuss the differences between the peer-to-peer implementation in Dendrite and the standard, and why they are necessary.
    This includes describing the Yggdrasil P2P network.
    Maybe we'll want to propose a change?

\section{Official Homeservers}
The Matrix organization has two official homeservers, Synapse\cite{matrix_org_synapse} and Dendrite\cite{matrix_org_dendrite}.
Homeservers perform the bulk of the work in the Matrix network.

\subsection{Synapse}
TODO:
    Describe Synapse, show snippets of salient parts (as this is the reference implementation, and might clarify some ambiguities in the standard).

\subsection{Dendrite}
Because of the performance and scalability issues that Synapse faces, it is not the base for future experimentation such as peer-to-peer infrastructure.
Instead, the bulk of that work goes on in the Dendrite implementation.
The source code is hosted on \url{https://github.com/matrix-org/dendrite}.

\begin{figure}
    \centering
    \resizebox{0.9\linewidth}{!}{\input{graphics/dendrite_design.tex}}
    \caption{
        The homeserver can be separated into two main components: \textit{writers} and \textit{readers}.
        Writers respond to API requests by appending to the event log.
        Readers respond to API requests by returning information from the event log.
        Source: \cite{dendrite_design_md}.
    }
    \label{fig:dendrite_design}
\end{figure}

\paragraph{Dendrite Architecture}
The Dendrite design aims to increase simplicity and improve scalability issues in Synapse by using a log based architecture for events.
The central concept is therefore the \textit{event log} which is a history of everything that has happened in a room.
The event log is append only, and accessed by two types of components: \textit{writers} and \textit{readers}.
An example of a writer could be the API that marks a user as active.
A reader could be the logic that synchronizes state with the client.
Figure \ref{fig:dendrite_design} provides a high-level illustration of the flow of data in this design.
Writers and readers must also have some way of computing the room state from the event log, or querying the room state from a central mediator component, such as a room server.
This allows writers to verify that an event is valid before appending it to the log.
Readers in a similar manner use the room state to know which servers and users have enough permissions to view the events.

\paragraph{Dendrite Code}
Dendrite is written in Go\cite{golang_org} and separated into several packages.
The Go programming language supports Android compilation, and Dendrite should therefore be portable to the smartphone.
The peer-to-peer code is implemented on the \texttt{master} branch for WASM, and depends on sqlite, which allows the homeserver to run completely in the browser.
Unfortunately, the WASM implementation of peer-to-peer Dendrite does not support cross-compilation for Android, and must instead be in pure Go.
The \texttt{p2p} branch has a pure Go implementation of peer-to-peer, but is still using postgres.
In order to use the latest developments for peer-to-peer Matrix, the \texttt{p2p} branch must be merged with \texttt{master}.

\section{Mobile Clients}
\subsection{Riot}
\subsection{RiotX}

% \section{Problem Statement}
% \subsection{Requirements for Mobile}
% The Application Service, Identity Service and Push Gateway \ac{API}s are not strictly necessary for a minimal version of peer-to-peer Matrix.
% The core functionality is provided by the client-server and server-server \ac{API}s.
% There are pre-existing implementations of both homeservers and clients which could be combined in order to provide such a service.

% \begin{itemize}
%     \item 
% \end{itemize}
